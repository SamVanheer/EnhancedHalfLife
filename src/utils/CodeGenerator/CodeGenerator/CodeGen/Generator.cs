using CodeGenerator.Processing;
using CodeGenerator.Utility;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;

namespace CodeGenerator.CodeGen
{
    /// <summary>
    /// Given as set of code to generate, generates header and source files as needed
    /// </summary>
    public class Generator
    {
        private const string HeaderFileExtension = ".hpp";
        private const string SourceFileExtension = ".cpp";

        public static readonly string GeneratedDirectory = "generated" + Path.DirectorySeparatorChar;
        private const string GeneratedSourceName = "ehl_generated" + SourceFileExtension;
        private const string GeneratedFileNameSuffix = ".generated";

        private readonly string _generatedDirectory;
        private readonly ImmutableDictionary<string, ProcessedFileInfo> _processedFileInfo;
        private readonly GeneratedCode _generatedCode;

        private readonly HashSet<string> _generatedFileNames = new();

        public Generator(string binaryDirectory, ImmutableDictionary<string, ProcessedFileInfo> processedFileInfo, GeneratedCode generatedCode)
        {
            _generatedDirectory = Path.Join(binaryDirectory.NormalizeSlashes(), GeneratedDirectory);
            _processedFileInfo = processedFileInfo;
            _generatedCode = generatedCode;
        }

        public void Generate()
        {
            _generatedFileNames.Clear();

            Directory.CreateDirectory(_generatedDirectory);

            var heading = @$"//Automatically generated by Enhanced Half-Life Code Generator
//{DateTimeOffset.Now}
//DO NOT EDIT

";

            GenerateHeaders(heading);
            GenerateSources(heading);
        }

        private void GenerateHeaders(string heading)
        {
            foreach (var data in _generatedCode.Classes)
            {
                var fileName = GetBaseFileName(data.FileName) + HeaderFileExtension;
                _generatedFileNames.Add(fileName);
                File.WriteAllText(fileName, heading + data.GenerateFullDeclaration());
            }
        }

        private void GenerateSources(string heading)
        {
            foreach (var data in _generatedCode.Classes)
            {
                var fileName = GetBaseFileName(data.FileName) + SourceFileExtension;
                _generatedFileNames.Add(fileName);
                File.WriteAllText(fileName, heading + data.GenerateFullDefinition());
            }

            //Generate the automatically included source file
            var generatedSourceFileName = _generatedDirectory + GeneratedSourceName;
            _generatedFileNames.Add(generatedSourceFileName);

            using var writer = File.CreateText(generatedSourceFileName);

            writer.Write(heading);

            foreach (var data in _generatedCode.Classes)
            {
                //Should never happen
                if (!_processedFileInfo.TryGetValue(data.FileName, out var processedInfo))
                {
                    throw new ProcessingException($"Tried to add generated source file for header \"{data.FileName}\" not processed by this tool");
                }

                processedInfo.HasGeneratedSourceFile = true;

                writer.WriteLine($"#include \"{GetBaseFileName(data.FileName)}{SourceFileExtension}\"");
            }

            //Include source files for headers that were not processed again
            foreach (var unprocessedFile in _processedFileInfo.Values
                .Where(f => f.HasGeneratedSourceFile && !f.FileProcessed))
            {
                //Also track these files
                var baseFileName = GetBaseFileName(unprocessedFile.FileName);

                _generatedFileNames.Add(baseFileName + HeaderFileExtension);

                var sourceFileName = baseFileName + SourceFileExtension;
                _generatedFileNames.Add(sourceFileName);

                writer.WriteLine($"#include \"{sourceFileName}\"");
            }

            //Remove any generated files that were not generated this run
            var allGeneratedFiles = Directory.EnumerateFiles(_generatedDirectory);

            var staleFiles = allGeneratedFiles
                .Select(f => Path.GetFullPath(f.NormalizeSlashes()))
                .Except(_generatedFileNames);

            foreach (var staleFile in staleFiles)
            {
                File.Delete(staleFile);
            }
        }

        private string GetBaseFileName(string fileName)
        {
            return _generatedDirectory + Path.GetFileNameWithoutExtension(fileName) + GeneratedFileNameSuffix;
        }
    }
}
